"""
CPU Scheduling Algorithms Simulation with Dear PyGui Visualization
===================================================================

This simulation demonstrates and compares various CPU scheduling algorithms:
- FCFS (First Come First Serve)
- SJF (Shortest Job First)
- Priority Scheduling
- Round Robin
- Heuristic AI CFS (Completely Fair Scheduler with AI enhancements)

Features:
- Real-time Gantt chart visualization for each algorithm
- Performance vs Load comparison graphs
- Statistical analysis and comparison
- All in one window with 4 tabs using Dear PyGui

Author: Scheduling Algorithm Simulator
"""

import dearpygui.dearpygui as dpg
from dataclasses import dataclass, field
from typing import List, Tuple, Optional
from copy import deepcopy
import random
import time

# ============================================================================
# PROCESS DATA STRUCTURE
# ============================================================================

@dataclass
class Process:
    """Process Control Block for simulation"""
    pid: int
    arrival_time: int
    burst_time: int
    priority: int = 0
    nice_value: int = 0
    
    remaining_time: int = field(init=False)
    start_time: int = -1
    finish_time: int = -1
    waiting_time: int = 0
    turnaround_time: int = 0
    response_time: int = -1
    
    vruntime: float = 0.0
    weight: int = 1024
    aging_boost: int = 0
    last_scheduled: int = 0
    
    def __post_init__(self):
        self.remaining_time = self.burst_time
        self.weight = self._nice_to_weight(self.nice_value)
    
    @staticmethod
    def _nice_to_weight(nice: int) -> int:
        weights = [
            88761, 71755, 56483, 46273, 36291, 29154, 23254, 18705, 14949, 11916,
            9548, 7620, 6100, 4904, 3906, 3121, 2501, 1991, 1586, 1277,
            1024, 820, 655, 526, 423, 335, 272, 215, 172, 137,
            110, 87, 70, 56, 45, 36, 29, 23, 18, 15
        ]
        idx = nice + 20
        return weights[max(0, min(39, idx))]


@dataclass
class GanttEntry:
    pid: int
    start: int
    end: int
    
    
@dataclass
class SchedulerResult:
    name: str
    gantt_chart: List[GanttEntry]
    processes: List[Process]
    avg_waiting_time: float
    avg_turnaround_time: float
    avg_response_time: float
    throughput: float
    cpu_utilization: float
    total_time: int


# ============================================================================
# SCHEDULING ALGORITHMS
# ============================================================================

class SchedulerBase:
    def __init__(self, name: str):
        self.name = name
        self.current_time = 0
        self.gantt_chart: List[GanttEntry] = []
        
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        raise NotImplementedError
    
    def calculate_metrics(self, processes: List[Process]) -> SchedulerResult:
        total_waiting = sum(p.waiting_time for p in processes)
        total_turnaround = sum(p.turnaround_time for p in processes)
        total_response = sum(p.response_time for p in processes if p.response_time >= 0)
        
        n = len(processes)
        total_burst = sum(p.burst_time for p in processes)
        
        return SchedulerResult(
            name=self.name,
            gantt_chart=self.gantt_chart,
            processes=processes,
            avg_waiting_time=total_waiting / n,
            avg_turnaround_time=total_turnaround / n,
            avg_response_time=total_response / n,
            throughput=n / self.current_time if self.current_time > 0 else 0,
            cpu_utilization=(total_burst / self.current_time * 100) if self.current_time > 0 else 0,
            total_time=self.current_time
        )


class FCFSScheduler(SchedulerBase):
    def __init__(self):
        super().__init__("FCFS")
    
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        procs = deepcopy(processes)
        procs.sort(key=lambda p: (p.arrival_time, p.pid))
        
        self.current_time = 0
        self.gantt_chart = []
        
        for proc in procs:
            if self.current_time < proc.arrival_time:
                self.current_time = proc.arrival_time
            
            proc.start_time = self.current_time
            proc.response_time = self.current_time - proc.arrival_time
            
            self.gantt_chart.append(GanttEntry(
                pid=proc.pid,
                start=self.current_time,
                end=self.current_time + proc.burst_time
            ))
            
            self.current_time += proc.burst_time
            proc.remaining_time = 0
            proc.finish_time = self.current_time
            proc.turnaround_time = proc.finish_time - proc.arrival_time
            proc.waiting_time = proc.turnaround_time - proc.burst_time
        
        return self.calculate_metrics(procs)


class SJFScheduler(SchedulerBase):
    def __init__(self, preemptive: bool = False):
        self.preemptive = preemptive
        name = "SRTF" if preemptive else "SJF"
        super().__init__(name)
    
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        procs = deepcopy(processes)
        self.current_time = 0
        self.gantt_chart = []
        completed = 0
        n = len(procs)
        
        last_proc = None
        last_start = 0
        
        while completed < n:
            available = [p for p in procs 
                        if p.arrival_time <= self.current_time and p.remaining_time > 0]
            
            if not available:
                next_arrival = min(p.arrival_time for p in procs if p.remaining_time > 0)
                self.current_time = next_arrival
                continue
            
            current_proc = min(available, key=lambda p: (p.remaining_time, p.arrival_time, p.pid))
            
            if current_proc.response_time == -1:
                current_proc.response_time = self.current_time - current_proc.arrival_time
                current_proc.start_time = self.current_time
            
            if self.preemptive:
                next_arrival = float('inf')
                for p in procs:
                    if p.arrival_time > self.current_time and p.remaining_time > 0:
                        next_arrival = min(next_arrival, p.arrival_time)
                
                run_time = min(current_proc.remaining_time, 
                              next_arrival - self.current_time if next_arrival != float('inf') else current_proc.remaining_time)
                
                if last_proc != current_proc.pid:
                    if last_proc is not None and last_start < self.current_time:
                        self.gantt_chart.append(GanttEntry(last_proc, last_start, self.current_time))
                    last_proc = current_proc.pid
                    last_start = self.current_time
                
                self.current_time += run_time
                current_proc.remaining_time -= run_time
                
                if current_proc.remaining_time == 0:
                    current_proc.finish_time = self.current_time
                    current_proc.turnaround_time = current_proc.finish_time - current_proc.arrival_time
                    current_proc.waiting_time = current_proc.turnaround_time - current_proc.burst_time
                    completed += 1
                    
                    if last_start < self.current_time:
                        self.gantt_chart.append(GanttEntry(current_proc.pid, last_start, self.current_time))
                    last_proc = None
            else:
                self.gantt_chart.append(GanttEntry(
                    pid=current_proc.pid,
                    start=self.current_time,
                    end=self.current_time + current_proc.remaining_time
                ))
                
                self.current_time += current_proc.remaining_time
                current_proc.remaining_time = 0
                current_proc.finish_time = self.current_time
                current_proc.turnaround_time = current_proc.finish_time - current_proc.arrival_time
                current_proc.waiting_time = current_proc.turnaround_time - current_proc.burst_time
                completed += 1
        
        return self.calculate_metrics(procs)


class PriorityScheduler(SchedulerBase):
    def __init__(self, preemptive: bool = False):
        self.preemptive = preemptive
        name = "Priority-P" if preemptive else "Priority"
        super().__init__(name)
    
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        procs = deepcopy(processes)
        self.current_time = 0
        self.gantt_chart = []
        completed = 0
        n = len(procs)
        
        while completed < n:
            available = [p for p in procs 
                        if p.arrival_time <= self.current_time and p.remaining_time > 0]
            
            if not available:
                next_arrival = min(p.arrival_time for p in procs if p.remaining_time > 0)
                self.current_time = next_arrival
                continue
            
            current_proc = min(available, key=lambda p: (p.priority, p.arrival_time, p.pid))
            
            if current_proc.response_time == -1:
                current_proc.response_time = self.current_time - current_proc.arrival_time
                current_proc.start_time = self.current_time
            
            self.gantt_chart.append(GanttEntry(
                pid=current_proc.pid,
                start=self.current_time,
                end=self.current_time + current_proc.remaining_time
            ))
            
            self.current_time += current_proc.remaining_time
            current_proc.remaining_time = 0
            current_proc.finish_time = self.current_time
            current_proc.turnaround_time = current_proc.finish_time - current_proc.arrival_time
            current_proc.waiting_time = current_proc.turnaround_time - current_proc.burst_time
            completed += 1
        
        return self.calculate_metrics(procs)


class RoundRobinScheduler(SchedulerBase):
    def __init__(self, time_quantum: int = 4):
        super().__init__(f"RR (TQ={time_quantum})")
        self.time_quantum = time_quantum
    
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        procs = deepcopy(processes)
        procs.sort(key=lambda p: (p.arrival_time, p.pid))
        
        self.current_time = 0
        self.gantt_chart = []
        
        ready_queue = []
        completed = 0
        n = len(procs)
        proc_index = 0
        
        while proc_index < n and procs[proc_index].arrival_time <= self.current_time:
            ready_queue.append(procs[proc_index])
            proc_index += 1
        
        while completed < n:
            if not ready_queue:
                if proc_index < n:
                    self.current_time = procs[proc_index].arrival_time
                    while proc_index < n and procs[proc_index].arrival_time <= self.current_time:
                        ready_queue.append(procs[proc_index])
                        proc_index += 1
                continue
            
            current_proc = ready_queue.pop(0)
            
            if current_proc.response_time == -1:
                current_proc.response_time = self.current_time - current_proc.arrival_time
                current_proc.start_time = self.current_time
            
            exec_time = min(self.time_quantum, current_proc.remaining_time)
            
            self.gantt_chart.append(GanttEntry(
                pid=current_proc.pid,
                start=self.current_time,
                end=self.current_time + exec_time
            ))
            
            self.current_time += exec_time
            current_proc.remaining_time -= exec_time
            
            while proc_index < n and procs[proc_index].arrival_time <= self.current_time:
                ready_queue.append(procs[proc_index])
                proc_index += 1
            
            if current_proc.remaining_time > 0:
                ready_queue.append(current_proc)
            else:
                current_proc.finish_time = self.current_time
                current_proc.turnaround_time = current_proc.finish_time - current_proc.arrival_time
                current_proc.waiting_time = current_proc.turnaround_time - current_proc.burst_time
                completed += 1
        
        return self.calculate_metrics(procs)


class HeuristicCFSScheduler(SchedulerBase):
    def __init__(self, time_quantum: int = 4):
        super().__init__("AI-CFS")
        self.time_quantum = time_quantum
        self.min_vruntime = 0.0
        self.WEIGHT_NICE_0 = 1024
        self.MAX_WAIT_THRESHOLD = 50
        self.INTERACTIVE_THRESHOLD = 20
    
    def _compute_heuristic_metrics(self, proc: Process, current_time: int):
        wait_time = current_time - proc.last_scheduled
        if wait_time > self.MAX_WAIT_THRESHOLD:
            proc.aging_boost = min(10, (wait_time - self.MAX_WAIT_THRESHOLD) // 5)
        else:
            proc.aging_boost = 0
        proc.last_scheduled = current_time
    
    def _update_vruntime(self, proc: Process, executed_time: int):
        delta_vruntime = (executed_time * self.WEIGHT_NICE_0) / proc.weight
        proc.vruntime += delta_vruntime
    
    def _select_next_process(self, available: List[Process], current_time: int) -> Optional[Process]:
        if not available:
            return None
        
        best_proc = None
        best_score = float('inf')
        
        for proc in available:
            self._compute_heuristic_metrics(proc, current_time)
            score = proc.vruntime
            score -= proc.aging_boost * 100
            if proc.remaining_time < self.INTERACTIVE_THRESHOLD:
                score -= 50
            if proc.remaining_time > 50:
                score += 10
            
            if score < best_score:
                best_score = score
                best_proc = proc
        
        return best_proc
    
    def schedule(self, processes: List[Process]) -> SchedulerResult:
        procs = deepcopy(processes)
        
        for p in procs:
            p.vruntime = self.min_vruntime
            p.last_scheduled = p.arrival_time
        
        self.current_time = 0
        self.gantt_chart = []
        completed = 0
        n = len(procs)
        
        last_proc_pid = None
        last_start = 0
        
        while completed < n:
            available = [p for p in procs 
                        if p.arrival_time <= self.current_time and p.remaining_time > 0]
            
            if not available:
                next_arrival = min(p.arrival_time for p in procs if p.remaining_time > 0)
                self.current_time = next_arrival
                continue
            
            current_proc = self._select_next_process(available, self.current_time)
            
            if current_proc.response_time == -1:
                current_proc.response_time = self.current_time - current_proc.arrival_time
                current_proc.start_time = self.current_time
            
            time_slice = max(2, (self.time_quantum * self.WEIGHT_NICE_0) // current_proc.weight)
            
            next_arrival = float('inf')
            for p in procs:
                if p.arrival_time > self.current_time and p.remaining_time > 0:
                    next_arrival = min(next_arrival, p.arrival_time)
            
            exec_time = min(time_slice, current_proc.remaining_time,
                           int(next_arrival - self.current_time) if next_arrival != float('inf') else time_slice)
            exec_time = max(1, exec_time)
            
            if last_proc_pid != current_proc.pid:
                if last_proc_pid is not None and last_start < self.current_time:
                    self.gantt_chart.append(GanttEntry(last_proc_pid, last_start, self.current_time))
                last_proc_pid = current_proc.pid
                last_start = self.current_time
            
            self.current_time += exec_time
            current_proc.remaining_time -= exec_time
            self._update_vruntime(current_proc, exec_time)
            
            active_vruntimes = [p.vruntime for p in procs if p.remaining_time > 0]
            if active_vruntimes:
                self.min_vruntime = min(active_vruntimes)
            
            if current_proc.remaining_time == 0:
                current_proc.finish_time = self.current_time
                current_proc.turnaround_time = current_proc.finish_time - current_proc.arrival_time
                current_proc.waiting_time = current_proc.turnaround_time - current_proc.burst_time
                completed += 1
                
                if last_start < self.current_time:
                    self.gantt_chart.append(GanttEntry(current_proc.pid, last_start, self.current_time))
                last_proc_pid = None
        
        return self.calculate_metrics(procs)


# ============================================================================
# DEAR PYGUI VISUALIZATION
# ============================================================================

class SchedulerGUI:
    COLORS = [
        (255, 107, 107, 255),
        (78, 205, 196, 255),
        (69, 183, 209, 255),
        (150, 206, 180, 255),
        (255, 234, 167, 255),
        (221, 160, 221, 255),
        (152, 216, 200, 255),
        (247, 220, 111, 255),
        (187, 143, 206, 255),
        (133, 193, 233, 255),
    ]
    
    def __init__(self, results: List[SchedulerResult], load_levels: List[int], metrics_by_load: dict):
        self.results = results
        self.load_levels = load_levels
        self.metrics_by_load = metrics_by_load
        self.process_colors = {}
        self.animation_time = 0
        self.animation_running = False
        self.max_time = max(r.total_time for r in results)
        
        all_pids = set()
        for result in results:
            for entry in result.gantt_chart:
                all_pids.add(entry.pid)
        for i, pid in enumerate(sorted(all_pids)):
            self.process_colors[pid] = self.COLORS[i % len(self.COLORS)]
    
    def setup_gui(self):
        dpg.create_context()
        dpg.create_viewport(title="CPU Scheduling Algorithms Simulator", width=1400, height=900)
        
        with dpg.window(label="Scheduler Simulator", tag="main_window", no_close=True):
            dpg.add_text("CPU Scheduling Algorithms Simulation", color=(100, 200, 255))
            dpg.add_separator()
            
            with dpg.tab_bar(tag="main_tabs"):
                with dpg.tab(label="Gantt Charts"):
                    self._create_gantt_tab()
                
                with dpg.tab(label="Performance Comparison"):
                    self._create_performance_tab()
                
                with dpg.tab(label="Performance vs Load"):
                    self._create_load_analysis_tab()
                
                with dpg.tab(label="Real-time Animation"):
                    self._create_animation_tab()
        
        dpg.setup_dearpygui()
        dpg.set_primary_window("main_window", True)
        dpg.show_viewport()
    
    def _create_gantt_tab(self):
        dpg.add_text("Gantt Charts for All Scheduling Algorithms", color=(255, 215, 0))
        dpg.add_separator()
        
        # Legend
        with dpg.group(horizontal=True):
            dpg.add_text("Legend: ")
            for pid, color in sorted(self.process_colors.items()):
                dpg.add_text(f"[P{pid}]", color=color[:3])
        
        dpg.add_separator()
        
        for idx, result in enumerate(self.results):
            with dpg.collapsing_header(label=f"{result.name}", default_open=True):
                with dpg.plot(label="", height=100, width=-1, tag=f"gantt_plot_{idx}"):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Time", tag=f"gantt_x_{idx}")
                    dpg.set_axis_limits(f"gantt_x_{idx}", 0, result.total_time + 2)
                    
                    with dpg.plot_axis(dpg.mvYAxis, label="", tag=f"gantt_y_{idx}", no_tick_labels=True):
                        dpg.set_axis_limits(f"gantt_y_{idx}", 0, 1)
                        
                        for entry in result.gantt_chart:
                            color = self.process_colors.get(entry.pid, (128, 128, 128, 255))
                            
                            # Draw bar using bar_series with custom positioning
                            x_center = (entry.start + entry.end) / 2
                            width = entry.end - entry.start
                            
                            with dpg.theme() as item_theme:
                                with dpg.theme_component(dpg.mvBarSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Fill, color, category=dpg.mvThemeCat_Plots)
                            
                            series = dpg.add_bar_series([x_center], [0.6], weight=width * 0.95)
                            dpg.bind_item_theme(series, item_theme)
                
                # Process labels for this chart
                gantt_text = "Timeline: "
                for entry in result.gantt_chart:
                    gantt_text += f"[{entry.start}-{entry.end}:P{entry.pid}] "
                dpg.add_text(gantt_text[:120] + "..." if len(gantt_text) > 120 else gantt_text, color=(150, 150, 150))
                
                metrics_text = f"Avg Wait: {result.avg_waiting_time:.1f} | Avg TAT: {result.avg_turnaround_time:.1f} | CPU: {result.cpu_utilization:.1f}%"
                dpg.add_text(metrics_text, color=(180, 180, 180))
    
    def _create_performance_tab(self):
        dpg.add_text("Performance Metrics Comparison", color=(255, 215, 0))
        dpg.add_separator()
        
        names = [r.name for r in self.results]
        x_vals = list(range(len(names)))
        
        with dpg.group(horizontal=True):
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Average Waiting Time", color=(100, 200, 255))
                with dpg.plot(label="", height=280, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Algorithm", tag="wait_x", no_tick_labels=True)
                    with dpg.plot_axis(dpg.mvYAxis, label="Time", tag="wait_y"):
                        waiting_times = [r.avg_waiting_time for r in self.results]
                        dpg.add_bar_series(x_vals, waiting_times, label="Waiting Time", weight=0.7)
                
                label_str = "  |  ".join([n for n in names])
                dpg.add_text(label_str, color=(150, 150, 150), wrap=640)
            
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Average Turnaround Time", color=(100, 200, 255))
                with dpg.plot(label="", height=280, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Algorithm", tag="tat_x", no_tick_labels=True)
                    with dpg.plot_axis(dpg.mvYAxis, label="Time", tag="tat_y"):
                        tat = [r.avg_turnaround_time for r in self.results]
                        dpg.add_bar_series(x_vals, tat, label="Turnaround Time", weight=0.7)
                
                dpg.add_text(label_str, color=(150, 150, 150), wrap=640)
        
        dpg.add_spacer(height=10)
        
        with dpg.group(horizontal=True):
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Average Response Time", color=(100, 200, 255))
                with dpg.plot(label="", height=280, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Algorithm", tag="resp_x", no_tick_labels=True)
                    with dpg.plot_axis(dpg.mvYAxis, label="Time", tag="resp_y"):
                        response = [r.avg_response_time for r in self.results]
                        dpg.add_bar_series(x_vals, response, label="Response Time", weight=0.7)
                
                dpg.add_text(label_str, color=(150, 150, 150), wrap=640)
            
            with dpg.child_window(width=650, height=350):
                dpg.add_text("CPU Utilization (%)", color=(100, 200, 255))
                with dpg.plot(label="", height=280, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Algorithm", tag="cpu_x", no_tick_labels=True)
                    with dpg.plot_axis(dpg.mvYAxis, label="Percentage", tag="cpu_y"):
                        cpu = [r.cpu_utilization for r in self.results]
                        dpg.add_bar_series(x_vals, cpu, label="CPU Utilization", weight=0.7)
                    dpg.set_axis_limits("cpu_y", 0, 110)
                
                dpg.add_text(label_str, color=(150, 150, 150), wrap=640)
        
        dpg.add_separator()
        dpg.add_text("Summary Table", color=(255, 215, 0))
        
        with dpg.table(header_row=True, borders_innerH=True, borders_outerH=True,
                      borders_innerV=True, borders_outerV=True):
            dpg.add_table_column(label="Algorithm")
            dpg.add_table_column(label="Avg Wait")
            dpg.add_table_column(label="Avg TAT")
            dpg.add_table_column(label="Avg Response")
            dpg.add_table_column(label="CPU Util %")
            dpg.add_table_column(label="Throughput")
            
            for r in self.results:
                with dpg.table_row():
                    dpg.add_text(r.name)
                    dpg.add_text(f"{r.avg_waiting_time:.2f}")
                    dpg.add_text(f"{r.avg_turnaround_time:.2f}")
                    dpg.add_text(f"{r.avg_response_time:.2f}")
                    dpg.add_text(f"{r.cpu_utilization:.1f}%")
                    dpg.add_text(f"{r.throughput:.4f}")
    
    def _create_load_analysis_tab(self):
        dpg.add_text("Performance vs System Load Analysis", color=(255, 215, 0))
        dpg.add_separator()
        
        scheduler_names = list(self.metrics_by_load.keys())
        line_colors = [
            (255, 107, 107),
            (78, 205, 196),
            (69, 183, 209),
            (150, 206, 180),
            (255, 234, 167),
            (221, 160, 221),
        ]
        
        with dpg.group(horizontal=True):
            dpg.add_text("Legend: ")
            for i, name in enumerate(scheduler_names):
                color = line_colors[i % len(line_colors)]
                dpg.add_text(f"[{name}]", color=color)
        dpg.add_separator()
        
        with dpg.group(horizontal=True):
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Waiting Time vs Load", color=(100, 200, 255))
                with dpg.plot(label="", height=300, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Number of Processes", tag="wl_x")
                    with dpg.plot_axis(dpg.mvYAxis, label="Avg Waiting Time", tag="wl_y"):
                        for i, name in enumerate(scheduler_names):
                            data = self.metrics_by_load[name]
                            y_data = [d['avg_waiting'] for d in data]
                            color = line_colors[i % len(line_colors)]
                            
                            with dpg.theme() as line_theme:
                                with dpg.theme_component(dpg.mvLineSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Line, color, category=dpg.mvThemeCat_Plots)
                            
                            series = dpg.add_line_series(list(self.load_levels), y_data, label=name)
                            dpg.bind_item_theme(series, line_theme)
                    dpg.add_plot_legend()
            
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Turnaround Time vs Load", color=(100, 200, 255))
                with dpg.plot(label="", height=300, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Number of Processes", tag="tl_x")
                    with dpg.plot_axis(dpg.mvYAxis, label="Avg Turnaround Time", tag="tl_y"):
                        for i, name in enumerate(scheduler_names):
                            data = self.metrics_by_load[name]
                            y_data = [d['avg_tat'] for d in data]
                            color = line_colors[i % len(line_colors)]
                            
                            with dpg.theme() as line_theme:
                                with dpg.theme_component(dpg.mvLineSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Line, color, category=dpg.mvThemeCat_Plots)
                            
                            series = dpg.add_line_series(list(self.load_levels), y_data, label=name)
                            dpg.bind_item_theme(series, line_theme)
                    dpg.add_plot_legend()
        
        dpg.add_spacer(height=10)
        
        with dpg.group(horizontal=True):
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Throughput vs Load", color=(100, 200, 255))
                with dpg.plot(label="", height=300, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Number of Processes", tag="thr_x")
                    with dpg.plot_axis(dpg.mvYAxis, label="Throughput", tag="thr_y"):
                        for i, name in enumerate(scheduler_names):
                            data = self.metrics_by_load[name]
                            y_data = [d['throughput'] for d in data]
                            color = line_colors[i % len(line_colors)]
                            
                            with dpg.theme() as line_theme:
                                with dpg.theme_component(dpg.mvLineSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Line, color, category=dpg.mvThemeCat_Plots)
                            
                            series = dpg.add_line_series(list(self.load_levels), y_data, label=name)
                            dpg.bind_item_theme(series, line_theme)
                    dpg.add_plot_legend()
            
            with dpg.child_window(width=650, height=350):
                dpg.add_text("Response Time vs Load", color=(100, 200, 255))
                with dpg.plot(label="", height=300, width=-1):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Number of Processes", tag="rl_x")
                    with dpg.plot_axis(dpg.mvYAxis, label="Avg Response Time", tag="rl_y"):
                        for i, name in enumerate(scheduler_names):
                            data = self.metrics_by_load[name]
                            y_data = [d['avg_response'] for d in data]
                            color = line_colors[i % len(line_colors)]
                            
                            with dpg.theme() as line_theme:
                                with dpg.theme_component(dpg.mvLineSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Line, color, category=dpg.mvThemeCat_Plots)
                            
                            series = dpg.add_line_series(list(self.load_levels), y_data, label=name)
                            dpg.bind_item_theme(series, line_theme)
                    dpg.add_plot_legend()
    
    def _create_animation_tab(self):
        dpg.add_text("Real-time Scheduling Animation", color=(255, 215, 0))
        dpg.add_separator()
        
        with dpg.group(horizontal=True):
            dpg.add_button(label="Play", callback=self._start_animation, tag="play_btn")
            dpg.add_button(label="Pause", callback=self._pause_animation, tag="pause_btn")
            dpg.add_button(label="Reset", callback=self._reset_animation, tag="reset_btn")
            dpg.add_text("    Current Time: ")
            dpg.add_text("0", tag="time_value", color=(0, 255, 0))
            dpg.add_text(f" / {self.max_time}")
        
        with dpg.group(horizontal=True):
            dpg.add_text("Animation Speed: ")
            dpg.add_slider_float(label="", default_value=1.0, min_value=0.1, max_value=5.0, 
                                tag="speed_slider", width=200)
        
        dpg.add_separator()
        
        with dpg.group(horizontal=True):
            dpg.add_text("Processes: ")
            for pid, color in sorted(self.process_colors.items()):
                dpg.add_text(f"[P{pid}]", color=color[:3])
        
        dpg.add_separator()
        
        for idx, result in enumerate(self.results):
            with dpg.collapsing_header(label=f"{result.name}", default_open=True):
                with dpg.plot(label="", height=80, width=-1, tag=f"anim_plot_{idx}"):
                    dpg.add_plot_axis(dpg.mvXAxis, label="Time", tag=f"anim_x_{idx}")
                    dpg.set_axis_limits(f"anim_x_{idx}", 0, self.max_time + 2)
                    
                    with dpg.plot_axis(dpg.mvYAxis, label="", tag=f"anim_y_{idx}", no_tick_labels=True):
                        dpg.set_axis_limits(f"anim_y_{idx}", 0, 1)
                        
                        # Pre-create bar series for animation
                        for j, entry in enumerate(result.gantt_chart):
                            color = self.process_colors.get(entry.pid, (128, 128, 128, 255))
                            
                            with dpg.theme() as item_theme:
                                with dpg.theme_component(dpg.mvBarSeries):
                                    dpg.add_theme_color(dpg.mvPlotCol_Fill, color, category=dpg.mvThemeCat_Plots)
                            
                            # Start with zero width
                            series = dpg.add_bar_series([entry.start], [0], weight=0.01,
                                                       tag=f"anim_bar_{idx}_{j}")
                            dpg.bind_item_theme(series, item_theme)
                        
                        # Time indicator line  
                        vline = dpg.add_vline_series([0], tag=f"anim_line_{idx}")
    
    def _start_animation(self):
        self.animation_running = True
    
    def _pause_animation(self):
        self.animation_running = False
    
    def _reset_animation(self):
        self.animation_running = False
        self.animation_time = 0
        dpg.set_value("time_value", "0")
        
        for idx, result in enumerate(self.results):
            if dpg.does_item_exist(f"anim_line_{idx}"):
                dpg.set_value(f"anim_line_{idx}", [[0]])
            
            for j, entry in enumerate(result.gantt_chart):
                tag = f"anim_bar_{idx}_{j}"
                if dpg.does_item_exist(tag):
                    dpg.set_value(tag, [[entry.start], [0]])
    
    def _update_animation(self):
        if self.animation_running and self.animation_time <= self.max_time:
            speed = dpg.get_value("speed_slider")
            self.animation_time += 0.1 * speed
            dpg.set_value("time_value", f"{self.animation_time:.1f}")
            
            for idx, result in enumerate(self.results):
                if dpg.does_item_exist(f"anim_line_{idx}"):
                    dpg.set_value(f"anim_line_{idx}", [[self.animation_time]])
                
                for j, entry in enumerate(result.gantt_chart):
                    tag = f"anim_bar_{idx}_{j}"
                    if dpg.does_item_exist(tag):
                        if self.animation_time >= entry.start:
                            current_end = min(entry.end, self.animation_time)
                            width = current_end - entry.start
                            x_center = entry.start + width / 2
                            if width > 0:
                                dpg.set_value(tag, [[x_center], [0.6]])
                                # Can't change weight dynamically, so just show/hide
            
            if self.animation_time > self.max_time:
                self.animation_running = False
    
    def run(self):
        self.setup_gui()
        
        while dpg.is_dearpygui_running():
            self._update_animation()
            dpg.render_dearpygui_frame()
            time.sleep(0.03)
        
        dpg.destroy_context()


# ============================================================================
# SIMULATION FUNCTIONS
# ============================================================================

def generate_random_processes(n: int, max_arrival: int = 50, 
                              max_burst: int = 30, seed: int = None) -> List[Process]:
    if seed is not None:
        random.seed(seed)
    
    processes = []
    for i in range(n):
        processes.append(Process(
            pid=i,
            arrival_time=random.randint(0, max_arrival),
            burst_time=random.randint(1, max_burst),
            priority=random.randint(1, 5),
            nice_value=random.randint(-10, 10)
        ))
    
    return processes


def run_all_schedulers(processes: List[Process]) -> List[SchedulerResult]:
    schedulers = [
        FCFSScheduler(),
        SJFScheduler(preemptive=False),
        SJFScheduler(preemptive=True),
        PriorityScheduler(preemptive=False),
        RoundRobinScheduler(time_quantum=4),
        HeuristicCFSScheduler(time_quantum=4)
    ]
    
    results = []
    for scheduler in schedulers:
        proc_copy = deepcopy(processes)
        result = scheduler.schedule(proc_copy)
        results.append(result)
        print(f"  ‚úì {scheduler.name} completed")
    
    return results


def run_load_analysis(load_levels: List[int], seed: int = 42) -> Tuple[List[int], dict]:
    schedulers = [
        ("FCFS", FCFSScheduler),
        ("SJF", lambda: SJFScheduler(preemptive=False)),
        ("SRTF", lambda: SJFScheduler(preemptive=True)),
        ("Priority", lambda: PriorityScheduler(preemptive=False)),
        ("Round Robin", lambda: RoundRobinScheduler(time_quantum=4)),
        ("AI-CFS", lambda: HeuristicCFSScheduler(time_quantum=4))
    ]
    
    metrics_by_scheduler = {name: [] for name, _ in schedulers}
    
    for load in load_levels:
        print(f"    Analyzing {load} processes...")
        processes = generate_random_processes(load, max_arrival=load*2, 
                                             max_burst=20, seed=seed+load)
        
        for name, scheduler_class in schedulers:
            scheduler = scheduler_class()
            result = scheduler.schedule(deepcopy(processes))
            
            metrics_by_scheduler[name].append({
                'avg_waiting': result.avg_waiting_time,
                'avg_tat': result.avg_turnaround_time,
                'avg_response': result.avg_response_time,
                'throughput': result.throughput,
                'cpu_util': result.cpu_utilization
            })
    
    return load_levels, metrics_by_scheduler


def print_comparison_table(results: List[SchedulerResult]):
    print("\n" + "="*85)
    print("                    SCHEDULING ALGORITHM COMPARISON")
    print("="*85)
    print(f"{'Algorithm':<20} {'Avg Wait':>10} {'Avg TAT':>10} {'Avg Resp':>10} {'CPU Util':>10} {'Throughput':>12}")
    print("-"*85)
    
    for r in results:
        print(f"{r.name:<20} {r.avg_waiting_time:>10.2f} {r.avg_turnaround_time:>10.2f} "
              f"{r.avg_response_time:>10.2f} {r.cpu_utilization:>9.1f}% {r.throughput:>12.4f}")
    
    print("="*85)
    
    best_wait = min(results, key=lambda r: r.avg_waiting_time)
    best_tat = min(results, key=lambda r: r.avg_turnaround_time)
    best_resp = min(results, key=lambda r: r.avg_response_time)
    
    print(f"\nüèÜ Best Waiting Time:    {best_wait.name} ({best_wait.avg_waiting_time:.2f})")
    print(f"üèÜ Best Turnaround Time: {best_tat.name} ({best_tat.avg_turnaround_time:.2f})")
    print(f"üèÜ Best Response Time:   {best_resp.name} ({best_resp.avg_response_time:.2f})")


# ============================================================================
# MAIN
# ============================================================================

def main():
    print("="*70)
    print("   CPU SCHEDULING ALGORITHMS SIMULATION")
    print("   Using Dear PyGui for Visualization")
    print("="*70)
    print("\nAlgorithms: FCFS, SJF, SRTF, Priority, Round Robin, AI-CFS")
    print("-"*70)
    
    print("\nüìã Generating sample processes...")
    processes = [
        Process(pid=0, arrival_time=0, burst_time=8, priority=3, nice_value=0),
        Process(pid=1, arrival_time=1, burst_time=4, priority=1, nice_value=-5),
        Process(pid=2, arrival_time=2, burst_time=9, priority=4, nice_value=5),
        Process(pid=3, arrival_time=3, burst_time=5, priority=2, nice_value=0),
        Process(pid=4, arrival_time=4, burst_time=2, priority=5, nice_value=-10),
        Process(pid=5, arrival_time=6, burst_time=6, priority=3, nice_value=0),
    ]
    
    print("\nProcess Table:")
    print("-"*50)
    print(f"{'PID':<6} {'Arrival':<10} {'Burst':<10} {'Priority':<10}")
    print("-"*50)
    for p in processes:
        print(f"P{p.pid:<5} {p.arrival_time:<10} {p.burst_time:<10} {p.priority:<10}")
    
    print("\nüîÑ Running scheduling algorithms...")
    results = run_all_schedulers(processes)
    
    print_comparison_table(results)
    
    print("\nüìà Running performance vs load analysis...")
    load_levels = [5, 10, 15, 20, 25, 30]
    load_levels, metrics = run_load_analysis(load_levels)
    
    print("\nüñ•Ô∏è  Launching Dear PyGui visualization...")
    print("   4 Tabs: Gantt Charts | Performance | Load Analysis | Animation")
    print("   (Close the window to exit)")
    
    gui = SchedulerGUI(results, load_levels, metrics)
    gui.run()


if __name__ == "__main__":
    main()
